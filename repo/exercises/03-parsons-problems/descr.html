<div>
    <p>
        This exercises features <b>Parson's problems</b>.
        These are programming problems where you are given the correct lines of code to
        write an alogrithm -- but it is up to you to arrange them in the right order!
    </p>

    <h3> Q1: Currying and uncurrying </h3>

    <p>
        Match the correct line of code to the respective function, curry or uncurry.

        <ul>
            <li> <code> fun (y,x) -> f y x </code> </li>
            <li> <code> fun x y -> f (x, y) </code> </li>
        </ul>
    </p>

    <h3> Q2: all_primes </h3>
    Write a function that calculates all prime numbers within a given range <code>a, b</code>
    This will require writing a helper function, <code>is_prime</code> that determine if a given integer is prime!
    Note the lines of code for both <code>is_prime, all_primes</code> are jumbled together! Also, the lines provided may
    require indentation!

    <code>
    <pre>
let n = max n (-n) in
if is_prime a then a :: rest else rest;;
let rec is_not_divisor d =
d * d > n || (n mod d <> 0 && is_not_divisor (d + 1))
in
let rest = all_primes (a + 1) b in
is_not_divisor 2
if a > b then [] else
    </pre>
    </code>


    <h3> Q3: mode </h3>
    <code>mode : 'a list -> 'a</code> is a function that takes a list containing <em>any-type ('a)</em> elements and
    returns
    the most common one (aka the mode of the distribution represented by the list).
    In case of tie (two or more elements have equal counts), return the element appearing latest in the list.
    <code>
    <pre>
| [] -> if cur_num > max_num then cur_el else max_el
| [] -> failwith "List too small."
| hd :: tl when cur_num > max_num ->
| hd :: tl -> 
| hd :: tl when hd = cur_el ->
| hd :: tl ->
aux tl (hd, 1) cur_stats
aux tl (cur_el, cur_num + 1) max_stats
aux tl (hd, 1) (hd, 1)
aux tl (hd, 1) max_stats
match l with
    </pre>
    </code>

    <h3> Q4: Making change </h3>
    In this exercise, you are to construct an algorithm that given
    a list of coins and target amount of money, returns a list of coins totalling the target amount.
    Ex. finding change for $11 with coins = [2;3;5] should return [5;3;3]. 
    You assume you have an infinite amount of the coins.
    This algorithm will use exceptions.

    <code>
    <pre>
if amt = 0 then [] 
coin :: change coins (amt - coin)
| coin::cs ->  
if coin > amt then
change cs amt
| [] -> raise Change
with Change -> change cs amt
else 
try 
    </pre>
    </code>
</div>
